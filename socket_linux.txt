在linux中，我们发送数据需要进行数据包的协议封装
及:
    
        {链路层{网络层{传输层{应用层{数据包}}}}}

arp 是存储的我们的物理地址，即计算机的网卡硬件地址
ip的字节段是32位字节
tcp/udp port 16位 最大可传输65535

socket---套接字

linux中一个文件只有两个缓冲区，分别是读和写，两个缓冲去互不干扰，
当对文件进行读的时候不会影响你的写入，两个缓冲区都是独立的




socket---套接字

linux中一个文件只有两个缓冲区，分别是读和写，两个缓冲去互不干扰，及
两个文件的缓冲区都是相互独立的


              读--> [文件]<--写


而在socket的编成中
文件的传输也是分为两个端，一个是发送端一个是接受端，
发送的端数据由接受端接手数据

        |----[发送端]---------->[接受端]-----|

       sfd                                   cfd

        |----[接收端]<----------[发送端]-----|

socket和linux文件的缓冲同理
所以我们在进行socket是成对出现的
socket需要绑定一个ip地址

在进行网络传输的时候由本地发送数据，到路由上，路由根据自己的路由表
选择下一个路由，这下一个路由称为下一跳，
如果路由的下一跳，断网，此时路由也无处可走，那么他将报错，并原路返回，到
自己的发送端


前面我们说了，数据的发送，其实还有一个需要说的就是字节序
在我们的网络中字节序是用大端法存储，而我们的操作系统是用的小端法存储，
先讲一下大端法存储

例：
int a = 0x12345678

        地址  大端法  小端法
        1004 |  78      12
        1003 |  56      34
        1002 |  34      56
        1001 |  12      78
而我们使用的计算机是进行小端法存储的，
所一我们需要进行字节序的转换
TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP
段格式，地址0-1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址是0x03,
  高地址存0xe8,，也就是先发0x03，再发0xe8,这16位在发送主机的缓冲区中也应该是
  1000（0xe803），而不是1000,因此，发送主机把1000,填写到发送换缓冲区前，需要
  做字节序的转换。同样的接受主机如果是小字节序，接受到16位的源端口好也要做字节
  序的转换。

在c语言中可以使用 <arpa/inet.h>库
uint32_t htonl(uint32_t hostlong)   前面讲过32位的ip，在此是将本地字节序转换
网络字节序
uint16_t htons(uint32_t hostshort)  16位端口号，在此是将本地端口号转换成网络
字节序
uint32_t ntonl(uint32_t hctlong)    网络字节序转换成本地字节序
uint16_t ntohs(uint16_t hetsshort)  网络字节序列转换成本地字节序列
在linux中提供了直接转换的函数
转换网络字节序              inet_pton()
网络字节序转换本地字节序    inet_ntop()
  ____________________________________
  l表示长整形数，32位，s表示短整形数，16位
  _____________________________________________________________
INADDR_ANY 自动分配当前可用ip 需要使用htol进行强行转换网络字节序

socket(int af ,int type,int protocol); //函数原型
af是指ip地址类型，常用的有AF_INET和AF_INET6 。
AF是"Address Family"的简写，
INET是'inetnet'的简写，
  AF_INET 表示ipv4地址，
  AF_INET6是值ipv6地址
type 是指数据传输的套接子类型，
  常用的有SOCK_STREAM(流试套接字/面向链接的套接字类型)
  和SOCK_DGRAM(数据报套接字类型/无链接的套接字类型) 
protocol 表示传输协议，常用的传输协议有IPPROTO_TCP 和IPPTOTO_UDP分别表示tcp传输协议
  和UDP传输协议，
int bind(int sock,struct sockaddr *addr ,socklen_t addrlen);
sock 为socket文件描述符
addr 为sockaddr结构体指针
addlen为addr变量的大小




数据报接口，两个对等的进程之间不需要逻辑连接，只需要向对象的进程发送一个套接字报文，
因此数据提供五连接服务，
字节流，要求在交换数据之前，在本地套接字如通信对等的进程（端口）的套接字之间建立一个逻辑链接
————————————————————————————————————————————————————————————————————————————————————————————
数据报是自带报文的，因此发送数据报类似寄信，你可以寄很多信，但是你不能保证信的到达顺序，也不能
保证信的一定可以安全到达。每个邮件都是附带地址的，因此每个邮件都是独立的，所以你可以发送给不同
的人。
————————————————————————————————————————————————————————————————————————————————————————————
面向链接的通信，就像给对方打电话，首先需要通过电话和对方建立连接，链接好之后，彼此才能通信，每
个链接就像点对点链接，对话不包含地址信息,就像呼叫的两端存在点对点关系的虚拟链接，并且链接本身
指特定的源和目的地。


SOCK_STREAM 套接字，提供字节流服务，所以应用本身分辨不出报文的界限，这就意味着SOCK_STREAM 套接
字读取数据时，他也不会返回进程所写的字节数。最终可的发送过来的数据也需要通过调用各种函数才能得到。
SOCK_SEQPACKET 套接字提供报文服务，这意味着，SOCK_SEQPACKET 套接字，接受的字节数和发送的字节数
一致。
    
     ____________________________________
    |[应用层] -                          | 
    |[表示层] |---------> [应用层]       |
    |[会话层] -                          |
    |[传输层] ----------> [传输层]       |
    |[网络层] ----------> [网络层]       |
    |[数据链路层] -|                     |
    |[物理层]     -|----->[网络接口层]   |
    |____________________________________|



  SOCK_RAW 套接字提供数据报接口，用于访问下面的网络接口曾（因特网中的ip层）使用这个接口时，应用程序
负责构建自己的协议头部，因为这是传输协议（TCP/IP）绕过了，当创建一个原始的套接子，需要使用超级用户
权限，这样可以防止恶意的程序绕过内建安全机制来传见报文。
调用SOCKET和调用open类似，在两种情况下均可获得1/0的文件描述符，当不再需要该文件时，可以调用close关闭
或套接字的访问，并且释放描述符，以便下一重新使用。
套接字本质上是文件描述符，但不是所有的文件描述符都使用与套接字描述符。
———————————————————————————————————————————————————————————————————————————————————————————————
int socket(int domain , int type,int protocol);
domain (域) 确定通性特性，包括地址格式。
大多数系统定义了AF_LOCAL域，这是AF_UNIX 别名   AF_UNSPEC，域可以代表任何域，历史上，有些平台还定义了
其他网络协议，如AF_IPX代表nctuare协议族，但是这些协议族都没有被posix.1标注定义
          AF_INET   ipv4因特域
          AF_INET6  ipv6因特域
          AF_UNIX   unix域
          AF_UNSPEC   未指定
 type 确定套接字类型，进一步确定通信特征
 类型                               描述
 SOCK_DGRAM ------------>固定长度，不可靠，无连接的报文传递。
 SOCK_RAM   ------------>ip协议的数据接口
 SOCK_SEQPACKET -------->固定长度，有序的，可靠的，面向连接的报文传递
 SOCK_STREAM ----------->有序的，可靠的，双向的，面向连接的字节流传递
protocol 表示为给定域和套接字类型给定一个协议，当同一个域支持多个协议，我们可以选择一个特定的协议
IPPROTO_TCP tcp传输控制协议
IPPROTO_RAM  原始的数据包协议
IPPROTO_ICMP 因特网控制协议
IPPROTO_ipv4 ipv4网络协议
IPPROTO_ipv6 ipv6网络协议
IPPROTO_UDP  用户数据报协议
————————————————————————————————————————————————————————————————————————————————————————————
套接字是双向的，我们可以使用shudowm来关闭一个套接字的1/0
____________________________________________________________________________________________
|#include<sys/socket.h>
|int shudowm(int sockefd,int how);
|//如果how是SHUT_RO 则关闭读数据，如果是SHUT_WR 则关闭发送数据，如果是SHUT_ROWR则关闭读取，和发送数据
|
|



———————————————————————————————————————————————————————————————————————————————————————————————
|#include<arpa/inet.h>
|const char * inet_ntop(int domain,const void * restrite addr,char *restrite str ,socklen_t size);
|//将网络字节序，转换成文本的字符串格式
|//int domain 只有两个参数（ipv4/ ipv6）AF_INET 和AF_INET6 ，addr 需要转换的字节序，
|//str 需要转换的字节序，size，因为str是存在缓冲区里面的，所以需要定义缓冲区的大小
|______________________________________________________________________________________________
|int inet_pton(int domain ,const char * restrict str ,void *restrict addr);
|//将文本字符串转换成网络字节序
|//domain 和上面的一样，str保存文本字节序，addr需要转换的字节序列

